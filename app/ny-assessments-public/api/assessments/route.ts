// NO top-level imports of loadAssessments/loadSchoolForName (ExcelJS)!
import { NextResponse } from "next/server";

/** Build an absolute origin for static fetches. */
function originFrom(req: Request) {
  const u = new URL(req.url);
  return `${u.protocol}//${u.host}`;
}

/** True when running on Netlify/production build. */
const IS_PROD = process.env.NODE_ENV === "production";

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);

  const subject = (searchParams.get("subject") || "ELA").trim();           // "ELA" | "Math"
  const level = (searchParams.get("level") || "city").trim().toLowerCase(); // "city"|"borough"|"district"|"school"
  const wantNames = searchParams.has("names");
  const school = (searchParams.get("school") || "").trim();

  try {
    const base = originFrom(req);

    // -------------- SCHOOL: names list --------------
    if (level === "school" && wantNames) {
      // Served from public/â€¦ generated by scripts/build-school-names.mjs
      const res = await fetch(`${base}/ny-assessments-public/school-names.json`, {
        cache: IS_PROD ? "force-cache" : "no-store",
      });
      if (!res.ok) throw new Error(`names.json ${res.status}`);
      const json = await res.json();
      const names = Array.isArray(json?.names) ? json.names : [];
      return NextResponse.json(
        { names },
        { headers: { "Cache-Control": "public, max-age=600, stale-while-revalidate=86400" } }
      );
    }

    // -------------- SCHOOL: per-school rows --------------
    if (level === "school") {
      if (!school || school === "All") {
        return NextResponse.json({}, { headers: { "Cache-Control": "no-store" } });
      }

      if (IS_PROD) {
        // In production we fetch the prebuilt school payload (keep bundle tiny)
        // Option A: single file per school (if you built them)
        //   /ny-assessments-public/schools/<url-encoded name>.json
        // Option B: index -> filename map, then fetch (uncomment if you use an index):
        //
        // const idxRes = await fetch(`${base}/ny-assessments-public/school-index.json`, { cache: "force-cache" });
        // const idx = idxRes.ok ? await idxRes.json() : { index: [] };
        // const entry = (idx.index || []).find((x: any) => String(x.name) === school);
        // const fileName = entry?.file || encodeURIComponent(school) + ".json";

        const fileName = encodeURIComponent(school) + ".json";
        const url = `${base}/ny-assessments-public/schools/${fileName}`;
        const res = await fetch(url, { cache: "force-cache" });
        if (!res.ok) throw new Error(`school payload not found for "${school}"`);
        const data = await res.json();
        return NextResponse.json(data, { headers: { "Cache-Control": "no-store" } });
      }

      // Dev fallback: read XLSX just-in-time via a dynamic import
      const { loadSchoolForName } = await import("@/lib/loadAssessments");
      const payload = await loadSchoolForName(subject, school);
      return NextResponse.json(payload, { headers: { "Cache-Control": "no-store" } });
    }

    // -------------- CITY / BOROUGH / DISTRICT --------------
    if (IS_PROD) {
      // Serve prebuilt static JSON (committed under public/)
      const url = `${base}/ny-assessments-public/data/${encodeURIComponent(subject)}/${encodeURIComponent(level)}.json`;
      const res = await fetch(url, { cache: "force-cache" });
      if (!res.ok) throw new Error(`${level}.json not found (${res.status})`);
      const data = await res.json();
      return NextResponse.json(
        data,
        { headers: { "Cache-Control": "public, max-age=300, stale-while-revalidate=3600" } }
      );
    }

    // Dev fallback: parse XLSX on the fly
    const { loadAssessments } = await import("@/lib/loadAssessments");
    const payload = await loadAssessments(subject, level);
    return NextResponse.json(
      payload,
      { headers: { "Cache-Control": "public, max-age=0, must-revalidate" } }
    );
  } catch (e: any) {
    console.error("[/ny-assessments-public/api/assessments] error:", e);
    return NextResponse.json({ error: e?.message || "Server error" }, { status: 500 });
  }
}
